package hgeom.hmesh.elements;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.IntFunction;
import java.util.function.Supplier;
import java.util.stream.IntStream;

import hgeom.hmesh.core.HConversion;
import hgeom.hmesh.core.ToHMeshConverter;

/**
 * Supplier of an indexed collection of faces. Each face is defined as an array
 * of indices to vertices
 *
 * @author Pierre B.
 */
public final class FaceSource {

	/**
	 *
	 */
	private final IntFunction<int[]> faces;

	/**
	 *
	 */
	private final Supplier<IntStream> indexSupplier;

	/**
	 * Constructs a face source from the specified list of faces
	 *
	 * @param faces a list of faces in which each face is defined as an array of
	 *              indices to vertices
	 */
	public FaceSource(List<int[]> faces) {
		this(faces::get, 0, faces.size());
	}

	/**
	 * Constructs a face source from the specified array of faces
	 *
	 * @param faces a array of faces in which each face is defined as an array
	 *              of indices to vertices
	 */
	public FaceSource(int[][] faces) {
		this(i -> faces[i], 0, faces.length);
	}

	/**
	 * Constructs a face source from a range of indices and a function returning
	 * a face according to an index. The collection of faces supplied by this
	 * source will be the result of the function applied on all the indices of
	 * the range
	 *
	 * @param faces               a function returning a face according to an
	 *                            index
	 * @param lowerInclusiveIndex the lower inclusive bound of the range of
	 *                            indices
	 * @param upperExclusiveIndex the upper exclusive bound of the range of
	 *                            indices
	 */
	public FaceSource(IntFunction<int[]> faces, int lowerInclusiveIndex,
			int upperExclusiveIndex) {

		this(faces, () -> IntStream.range(lowerInclusiveIndex,
				upperExclusiveIndex));
	}

	/**
	 * Constructs a face source from a index stream supplier and a function
	 * returning a face according to an index. The collection of faces supplied
	 * by this source will be the result of the function applied on all indices
	 * of a stream generated by the stream supplier
	 *
	 * @param faces             a function returning a face according to an
	 *                          index
	 * @param faceIndexSupplier the index stream supplier
	 */
	public FaceSource(IntFunction<int[]> faces,
			Supplier<IntStream> faceIndexSupplier) {

		this.faces = Objects.requireNonNull(faces);
		this.indexSupplier = Objects.requireNonNull(faceIndexSupplier);
	}

	/**
	 * Builds a half-edge data structure based on this face source
	 *
	 * @return an optional on a {@link HMesh} representing the half-edge data
	 *         structure; {@link Optional#empty()} if the building failed
	 */
	public Optional<HMesh> toHMesh() {
		return new ToHMeshConverter().convert(this).map(HConversion::mesh);
	}

	/**
	 * Builds a 2D half-edge data structure based on this face source and on the
	 * specified {@link Coord2DSource 2D coords source}
	 *
	 * @param coordsSource a 2D coords supplier for the coords of the vertices
	 *                     of the 2D half-edge data structure
	 * @return an optional on a {@link HMesh2D} representing the 2D half-edge
	 *         data structure; {@link Optional#empty()} if the building failed
	 */
	public Optional<HMesh2D> toHMesh(Coord2DSource coordsSource) {
		return new ToHMeshConverter().convert(this, coordsSource)
				.map(HConversion::mesh);
	}

	/**
	 * Builds a 3D half-edge data structure based on this face source and on the
	 * specified {@link Coord2DSource 3D coords source}
	 *
	 * @param coordsSource a 3D coords source for the coords of the vertices of
	 *                     the 3D half-edge data structure
	 * @return an optional on a {@link HMesh3D} representing the 3D half-edge
	 *         data structure; {@link Optional#empty()} if the building failed
	 */
	public Optional<HMesh3D> toHMesh(Coord3DSource coordsSource) {
		return new ToHMeshConverter().convert(this, coordsSource)
				.map(HConversion::mesh);
	}

	/**
	 * Returns the face with the specified index in this face source
	 *
	 * @param faceIndex index of the face to return
	 * @return the face with the specified index
	 */
	public int[] face(int faceIndex) {
		return faces.apply(faceIndex);
	}

	/**
	 * @return a stream on this source face indices
	 */
	public IntStream faceIndices() {
		return indexSupplier.get();
	}
}
